# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""The TimeTagger module measures timing events very accurately."""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")


# The Time Tagger library uses numpy to return array values
import numpy

try:
    import _TimeTagger
except:
    import platform
    import sys
    import os

    assert 'TIMETAGGER_INSTALL_PATH' in os.environ, 'The Time Tagger installation was not found. Please reinstall the Time Tagger Software suite.'

    # detect bitness and python version
    arch = 'x64' if platform.architecture()[0] == '64bit' else 'x86'
    version = str(sys.version_info.major) + '.' + str(sys.version_info.minor)

    # absolute path for the TimeTagger module
    path = os.environ['TIMETAGGER_INSTALL_PATH'] + '\\driver\\' + arch + '\\python' + version

    # add the new path
    if not path in sys.path:
        sys.path.append(path)

    try:
        import _TimeTagger
    except:
        assert version in ['2.7', '3.5', '3.6', '3.7', '3.8', '3.9'], 'This Python version is not supported by the Time Tagger software suite.'
        raise

    # clear all local variables
    del platform, sys, os, arch, version, path



try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_SwigPyIterator

    def value(self):
        r"""value(self) -> PyObject *"""
        return _TimeTagger.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""incr(self, n=1) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""decr(self, n=1) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""distance(self, x) -> ptrdiff_t"""
        return _TimeTagger.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""equal(self, x) -> bool"""
        return _TimeTagger.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(self) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator_copy(self)

    def next(self):
        r"""next(self) -> PyObject *"""
        return _TimeTagger.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(self) -> PyObject *"""
        return _TimeTagger.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(self) -> PyObject *"""
        return _TimeTagger.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""advance(self, n) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""__eq__(self, x) -> bool"""
        return _TimeTagger.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""__ne__(self, x) -> bool"""
        return _TimeTagger.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""__iadd__(self, n) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""__isub__(self, n) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""__add__(self, n) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(self, n) -> SwigPyIterator
        __sub__(self, x) -> ptrdiff_t
        """
        return _TimeTagger.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _TimeTagger:
_TimeTagger.SwigPyIterator_swigregister(SwigPyIterator)


def _timeout_handler(callback, timeout):
    r"""
        helper for splitting up timeouts in smaller calls. So CTRL-C will be able to interrupt blocking calls.
        timeout is in milliseconds, 0 means non-blocking, negative means no timeout.
        returns True on success and False on timeout.
    """
    import sys
    if sys.version_info.major < 3 or timeout == 0:
        return callback(timeout)

    maximum_timeout = 20

    if timeout < 0:
        while not callback(maximum_timeout):
            pass
        return True

    import time
    original_time = time.monotonic()
    while True:
        remaining_timeout = max(0,min(maximum_timeout, timeout - round((time.monotonic() - original_time)*1000)))
        if callback(remaining_timeout):
            return True
        if remaining_timeout == 0:
            return False

class UCharVector(object):
    r"""Proxy of C++ std::vector< unsigned char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.UCharVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.UCharVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.UCharVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< unsigned char >::size_type"""
        return _TimeTagger.UCharVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> UCharVector"""
        return _TimeTagger.UCharVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.UCharVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.UCharVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.UCharVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> UCharVector
        __getitem__(self, i) -> std::vector< unsigned char >::value_type const &
        """
        return _TimeTagger.UCharVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.UCharVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< unsigned char >::value_type"""
        return _TimeTagger.UCharVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.UCharVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.UCharVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< unsigned char >::size_type"""
        return _TimeTagger.UCharVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.UCharVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< unsigned char >::iterator"""
        return _TimeTagger.UCharVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< unsigned char >::iterator"""
        return _TimeTagger.UCharVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< unsigned char >::reverse_iterator"""
        return _TimeTagger.UCharVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< unsigned char >::reverse_iterator"""
        return _TimeTagger.UCharVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.UCharVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< unsigned char >::allocator_type"""
        return _TimeTagger.UCharVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.UCharVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< unsigned char >::iterator
        erase(self, first, last) -> std::vector< unsigned char >::iterator
        """
        return _TimeTagger.UCharVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> UCharVector
        __init__(self, other) -> UCharVector
        __init__(self, size) -> UCharVector
        __init__(self, size, value) -> UCharVector
        """
        _TimeTagger.UCharVector_swiginit(self, _TimeTagger.new_UCharVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.UCharVector_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< unsigned char >::value_type const &"""
        return _TimeTagger.UCharVector_front(self)

    def back(self):
        r"""back(self) -> std::vector< unsigned char >::value_type const &"""
        return _TimeTagger.UCharVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.UCharVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.UCharVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< unsigned char >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.UCharVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _TimeTagger.UCharVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< unsigned char >::size_type"""
        return _TimeTagger.UCharVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_UCharVector

# Register UCharVector in _TimeTagger:
_TimeTagger.UCharVector_swigregister(UCharVector)

class IntVector(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.IntVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.IntVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< int >::size_type"""
        return _TimeTagger.IntVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> IntVector"""
        return _TimeTagger.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> IntVector
        __getitem__(self, i) -> std::vector< int >::value_type const &
        """
        return _TimeTagger.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.IntVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< int >::value_type"""
        return _TimeTagger.IntVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.IntVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.IntVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< int >::size_type"""
        return _TimeTagger.IntVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.IntVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< int >::iterator"""
        return _TimeTagger.IntVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< int >::iterator"""
        return _TimeTagger.IntVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< int >::reverse_iterator"""
        return _TimeTagger.IntVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< int >::reverse_iterator"""
        return _TimeTagger.IntVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.IntVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< int >::allocator_type"""
        return _TimeTagger.IntVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.IntVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< int >::iterator
        erase(self, first, last) -> std::vector< int >::iterator
        """
        return _TimeTagger.IntVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> IntVector
        __init__(self, other) -> IntVector
        __init__(self, size) -> IntVector
        __init__(self, size, value) -> IntVector
        """
        _TimeTagger.IntVector_swiginit(self, _TimeTagger.new_IntVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.IntVector_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< int >::value_type const &"""
        return _TimeTagger.IntVector_front(self)

    def back(self):
        r"""back(self) -> std::vector< int >::value_type const &"""
        return _TimeTagger.IntVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.IntVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.IntVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< int >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.IntVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _TimeTagger.IntVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< int >::size_type"""
        return _TimeTagger.IntVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_IntVector

# Register IntVector in _TimeTagger:
_TimeTagger.IntVector_swigregister(IntVector)

class UIntVector(object):
    r"""Proxy of C++ std::vector< unsigned int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.UIntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.UIntVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.UIntVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< unsigned int >::size_type"""
        return _TimeTagger.UIntVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> UIntVector"""
        return _TimeTagger.UIntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.UIntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.UIntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.UIntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> UIntVector
        __getitem__(self, i) -> std::vector< unsigned int >::value_type const &
        """
        return _TimeTagger.UIntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.UIntVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< unsigned int >::value_type"""
        return _TimeTagger.UIntVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.UIntVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.UIntVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< unsigned int >::size_type"""
        return _TimeTagger.UIntVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.UIntVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< unsigned int >::iterator"""
        return _TimeTagger.UIntVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< unsigned int >::iterator"""
        return _TimeTagger.UIntVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< unsigned int >::reverse_iterator"""
        return _TimeTagger.UIntVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< unsigned int >::reverse_iterator"""
        return _TimeTagger.UIntVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.UIntVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< unsigned int >::allocator_type"""
        return _TimeTagger.UIntVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.UIntVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< unsigned int >::iterator
        erase(self, first, last) -> std::vector< unsigned int >::iterator
        """
        return _TimeTagger.UIntVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> UIntVector
        __init__(self, other) -> UIntVector
        __init__(self, size) -> UIntVector
        __init__(self, size, value) -> UIntVector
        """
        _TimeTagger.UIntVector_swiginit(self, _TimeTagger.new_UIntVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.UIntVector_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< unsigned int >::value_type const &"""
        return _TimeTagger.UIntVector_front(self)

    def back(self):
        r"""back(self) -> std::vector< unsigned int >::value_type const &"""
        return _TimeTagger.UIntVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.UIntVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.UIntVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< unsigned int >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.UIntVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _TimeTagger.UIntVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< unsigned int >::size_type"""
        return _TimeTagger.UIntVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_UIntVector

# Register UIntVector in _TimeTagger:
_TimeTagger.UIntVector_swigregister(UIntVector)

class LongVector(object):
    r"""Proxy of C++ std::vector< long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.LongVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.LongVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.LongVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< long long >::size_type"""
        return _TimeTagger.LongVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> LongVector"""
        return _TimeTagger.LongVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.LongVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.LongVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.LongVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> LongVector
        __getitem__(self, i) -> std::vector< long long >::value_type const &
        """
        return _TimeTagger.LongVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.LongVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< long long >::value_type"""
        return _TimeTagger.LongVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.LongVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.LongVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< long long >::size_type"""
        return _TimeTagger.LongVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.LongVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< long long >::iterator"""
        return _TimeTagger.LongVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< long long >::iterator"""
        return _TimeTagger.LongVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< long long >::reverse_iterator"""
        return _TimeTagger.LongVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< long long >::reverse_iterator"""
        return _TimeTagger.LongVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.LongVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< long long >::allocator_type"""
        return _TimeTagger.LongVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.LongVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< long long >::iterator
        erase(self, first, last) -> std::vector< long long >::iterator
        """
        return _TimeTagger.LongVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> LongVector
        __init__(self, other) -> LongVector
        __init__(self, size) -> LongVector
        __init__(self, size, value) -> LongVector
        """
        _TimeTagger.LongVector_swiginit(self, _TimeTagger.new_LongVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.LongVector_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< long long >::value_type const &"""
        return _TimeTagger.LongVector_front(self)

    def back(self):
        r"""back(self) -> std::vector< long long >::value_type const &"""
        return _TimeTagger.LongVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.LongVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.LongVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< long long >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.LongVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _TimeTagger.LongVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< long long >::size_type"""
        return _TimeTagger.LongVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_LongVector

# Register LongVector in _TimeTagger:
_TimeTagger.LongVector_swigregister(LongVector)

class ULongVector(object):
    r"""Proxy of C++ std::vector< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.ULongVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.ULongVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.ULongVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< unsigned long long >::size_type"""
        return _TimeTagger.ULongVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> ULongVector"""
        return _TimeTagger.ULongVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.ULongVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.ULongVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.ULongVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> ULongVector
        __getitem__(self, i) -> std::vector< unsigned long long >::value_type const &
        """
        return _TimeTagger.ULongVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.ULongVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< unsigned long long >::value_type"""
        return _TimeTagger.ULongVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.ULongVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.ULongVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< unsigned long long >::size_type"""
        return _TimeTagger.ULongVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.ULongVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< unsigned long long >::iterator"""
        return _TimeTagger.ULongVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< unsigned long long >::iterator"""
        return _TimeTagger.ULongVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _TimeTagger.ULongVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _TimeTagger.ULongVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.ULongVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< unsigned long long >::allocator_type"""
        return _TimeTagger.ULongVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.ULongVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< unsigned long long >::iterator
        erase(self, first, last) -> std::vector< unsigned long long >::iterator
        """
        return _TimeTagger.ULongVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> ULongVector
        __init__(self, other) -> ULongVector
        __init__(self, size) -> ULongVector
        __init__(self, size, value) -> ULongVector
        """
        _TimeTagger.ULongVector_swiginit(self, _TimeTagger.new_ULongVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.ULongVector_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< unsigned long long >::value_type const &"""
        return _TimeTagger.ULongVector_front(self)

    def back(self):
        r"""back(self) -> std::vector< unsigned long long >::value_type const &"""
        return _TimeTagger.ULongVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.ULongVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.ULongVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< unsigned long long >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.ULongVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _TimeTagger.ULongVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< unsigned long long >::size_type"""
        return _TimeTagger.ULongVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_ULongVector

# Register ULongVector in _TimeTagger:
_TimeTagger.ULongVector_swigregister(ULongVector)

class FloatVector(object):
    r"""Proxy of C++ std::vector< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.FloatVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.FloatVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< float >::size_type"""
        return _TimeTagger.FloatVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> FloatVector"""
        return _TimeTagger.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.FloatVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> FloatVector
        __getitem__(self, i) -> std::vector< float >::value_type const &
        """
        return _TimeTagger.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.FloatVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< float >::value_type"""
        return _TimeTagger.FloatVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.FloatVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.FloatVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< float >::size_type"""
        return _TimeTagger.FloatVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.FloatVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< float >::iterator"""
        return _TimeTagger.FloatVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< float >::iterator"""
        return _TimeTagger.FloatVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< float >::reverse_iterator"""
        return _TimeTagger.FloatVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< float >::reverse_iterator"""
        return _TimeTagger.FloatVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.FloatVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< float >::allocator_type"""
        return _TimeTagger.FloatVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.FloatVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< float >::iterator
        erase(self, first, last) -> std::vector< float >::iterator
        """
        return _TimeTagger.FloatVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> FloatVector
        __init__(self, other) -> FloatVector
        __init__(self, size) -> FloatVector
        __init__(self, size, value) -> FloatVector
        """
        _TimeTagger.FloatVector_swiginit(self, _TimeTagger.new_FloatVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.FloatVector_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< float >::value_type const &"""
        return _TimeTagger.FloatVector_front(self)

    def back(self):
        r"""back(self) -> std::vector< float >::value_type const &"""
        return _TimeTagger.FloatVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.FloatVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.FloatVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< float >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.FloatVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _TimeTagger.FloatVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< float >::size_type"""
        return _TimeTagger.FloatVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_FloatVector

# Register FloatVector in _TimeTagger:
_TimeTagger.FloatVector_swigregister(FloatVector)

class DoubleVector(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.DoubleVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.DoubleVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< double >::size_type"""
        return _TimeTagger.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> DoubleVector"""
        return _TimeTagger.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> DoubleVector
        __getitem__(self, i) -> std::vector< double >::value_type const &
        """
        return _TimeTagger.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.DoubleVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< double >::value_type"""
        return _TimeTagger.DoubleVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.DoubleVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.DoubleVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< double >::size_type"""
        return _TimeTagger.DoubleVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.DoubleVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< double >::iterator"""
        return _TimeTagger.DoubleVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< double >::iterator"""
        return _TimeTagger.DoubleVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< double >::reverse_iterator"""
        return _TimeTagger.DoubleVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< double >::reverse_iterator"""
        return _TimeTagger.DoubleVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.DoubleVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< double >::allocator_type"""
        return _TimeTagger.DoubleVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.DoubleVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< double >::iterator
        erase(self, first, last) -> std::vector< double >::iterator
        """
        return _TimeTagger.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> DoubleVector
        __init__(self, other) -> DoubleVector
        __init__(self, size) -> DoubleVector
        __init__(self, size, value) -> DoubleVector
        """
        _TimeTagger.DoubleVector_swiginit(self, _TimeTagger.new_DoubleVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.DoubleVector_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< double >::value_type const &"""
        return _TimeTagger.DoubleVector_front(self)

    def back(self):
        r"""back(self) -> std::vector< double >::value_type const &"""
        return _TimeTagger.DoubleVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.DoubleVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< double >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.DoubleVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _TimeTagger.DoubleVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< double >::size_type"""
        return _TimeTagger.DoubleVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_DoubleVector

# Register DoubleVector in _TimeTagger:
_TimeTagger.DoubleVector_swigregister(DoubleVector)

class StringVector(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.StringVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.StringVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::string >::size_type"""
        return _TimeTagger.StringVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> StringVector"""
        return _TimeTagger.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> StringVector
        __getitem__(self, i) -> std::vector< std::string >::value_type const &
        """
        return _TimeTagger.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.StringVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< std::string >::value_type"""
        return _TimeTagger.StringVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.StringVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.StringVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::string >::size_type"""
        return _TimeTagger.StringVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.StringVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::string >::iterator"""
        return _TimeTagger.StringVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::string >::iterator"""
        return _TimeTagger.StringVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::string >::reverse_iterator"""
        return _TimeTagger.StringVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::string >::reverse_iterator"""
        return _TimeTagger.StringVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.StringVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::string >::allocator_type"""
        return _TimeTagger.StringVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.StringVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::string >::iterator
        erase(self, first, last) -> std::vector< std::string >::iterator
        """
        return _TimeTagger.StringVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> StringVector
        __init__(self, other) -> StringVector
        __init__(self, size) -> StringVector
        __init__(self, size, value) -> StringVector
        """
        _TimeTagger.StringVector_swiginit(self, _TimeTagger.new_StringVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.StringVector_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< std::string >::value_type const &"""
        return _TimeTagger.StringVector_front(self)

    def back(self):
        r"""back(self) -> std::vector< std::string >::value_type const &"""
        return _TimeTagger.StringVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.StringVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.StringVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::string >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.StringVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _TimeTagger.StringVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::string >::size_type"""
        return _TimeTagger.StringVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_StringVector

# Register StringVector in _TimeTagger:
_TimeTagger.StringVector_swigregister(StringVector)

class StringList(object):
    r"""Proxy of C++ std::list< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.StringList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.StringList___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.StringList___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::list< std::string >::size_type"""
        return _TimeTagger.StringList___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> StringList"""
        return _TimeTagger.StringList___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.StringList___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.StringList___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.StringList___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> StringList
        __getitem__(self, i) -> std::list< std::string >::value_type const &
        """
        return _TimeTagger.StringList___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.StringList___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::list< std::string >::value_type"""
        return _TimeTagger.StringList_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.StringList_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.StringList_empty(self)

    def size(self):
        r"""size(self) -> std::list< std::string >::size_type"""
        return _TimeTagger.StringList_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.StringList_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::list< std::string >::iterator"""
        return _TimeTagger.StringList_begin(self)

    def end(self):
        r"""end(self) -> std::list< std::string >::iterator"""
        return _TimeTagger.StringList_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::list< std::string >::reverse_iterator"""
        return _TimeTagger.StringList_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::list< std::string >::reverse_iterator"""
        return _TimeTagger.StringList_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.StringList_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::list< std::string >::allocator_type"""
        return _TimeTagger.StringList_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.StringList_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::list< std::string >::iterator
        erase(self, first, last) -> std::list< std::string >::iterator
        """
        return _TimeTagger.StringList_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> StringList
        __init__(self, other) -> StringList
        __init__(self, size) -> StringList
        __init__(self, size, value) -> StringList
        """
        _TimeTagger.StringList_swiginit(self, _TimeTagger.new_StringList(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.StringList_push_back(self, x)

    def front(self):
        r"""front(self) -> std::list< std::string >::value_type const &"""
        return _TimeTagger.StringList_front(self)

    def back(self):
        r"""back(self) -> std::list< std::string >::value_type const &"""
        return _TimeTagger.StringList_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.StringList_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.StringList_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::list< std::string >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.StringList_insert(self, *args)

    def pop_front(self):
        r"""pop_front(self)"""
        return _TimeTagger.StringList_pop_front(self)

    def push_front(self, x):
        r"""push_front(self, x)"""
        return _TimeTagger.StringList_push_front(self, x)

    def reverse(self):
        r"""reverse(self)"""
        return _TimeTagger.StringList_reverse(self)
    __swig_destroy__ = _TimeTagger.delete_StringList

# Register StringList in _TimeTagger:
_TimeTagger.StringList_swigregister(StringList)

class EventVector(object):
    r"""Proxy of C++ std::vector< Event > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.EventVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.EventVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.EventVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< Event >::size_type"""
        return _TimeTagger.EventVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> EventVector"""
        return _TimeTagger.EventVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.EventVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.EventVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.EventVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> EventVector
        __getitem__(self, i) -> Event
        """
        return _TimeTagger.EventVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.EventVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> Event"""
        return _TimeTagger.EventVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.EventVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.EventVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< Event >::size_type"""
        return _TimeTagger.EventVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.EventVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< Event >::iterator"""
        return _TimeTagger.EventVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< Event >::iterator"""
        return _TimeTagger.EventVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< Event >::reverse_iterator"""
        return _TimeTagger.EventVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< Event >::reverse_iterator"""
        return _TimeTagger.EventVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.EventVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< Event >::allocator_type"""
        return _TimeTagger.EventVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.EventVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< Event >::iterator
        erase(self, first, last) -> std::vector< Event >::iterator
        """
        return _TimeTagger.EventVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> EventVector
        __init__(self, other) -> EventVector
        __init__(self, size) -> EventVector
        __init__(self, size, value) -> EventVector
        """
        _TimeTagger.EventVector_swiginit(self, _TimeTagger.new_EventVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.EventVector_push_back(self, x)

    def front(self):
        r"""front(self) -> Event"""
        return _TimeTagger.EventVector_front(self)

    def back(self):
        r"""back(self) -> Event"""
        return _TimeTagger.EventVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.EventVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.EventVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< Event >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.EventVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _TimeTagger.EventVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< Event >::size_type"""
        return _TimeTagger.EventVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_EventVector

# Register EventVector in _TimeTagger:
_TimeTagger.EventVector_swigregister(EventVector)

class EventVectorVector(object):
    r"""Proxy of C++ std::vector< std::vector< Event > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.EventVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.EventVectorVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.EventVectorVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< Event > >::size_type"""
        return _TimeTagger.EventVectorVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> EventVectorVector"""
        return _TimeTagger.EventVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.EventVectorVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.EventVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.EventVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> EventVectorVector
        __getitem__(self, i) -> EventVector
        """
        return _TimeTagger.EventVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.EventVectorVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> EventVector"""
        return _TimeTagger.EventVectorVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.EventVectorVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.EventVectorVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< Event > >::size_type"""
        return _TimeTagger.EventVectorVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.EventVectorVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< Event > >::iterator"""
        return _TimeTagger.EventVectorVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< Event > >::iterator"""
        return _TimeTagger.EventVectorVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< Event > >::reverse_iterator"""
        return _TimeTagger.EventVectorVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< Event > >::reverse_iterator"""
        return _TimeTagger.EventVectorVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.EventVectorVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< Event > >::allocator_type"""
        return _TimeTagger.EventVectorVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.EventVectorVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< Event > >::iterator
        erase(self, first, last) -> std::vector< std::vector< Event > >::iterator
        """
        return _TimeTagger.EventVectorVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> EventVectorVector
        __init__(self, other) -> EventVectorVector
        __init__(self, size) -> EventVectorVector
        __init__(self, size, value) -> EventVectorVector
        """
        _TimeTagger.EventVectorVector_swiginit(self, _TimeTagger.new_EventVectorVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.EventVectorVector_push_back(self, x)

    def front(self):
        r"""front(self) -> EventVector"""
        return _TimeTagger.EventVectorVector_front(self)

    def back(self):
        r"""back(self) -> EventVector"""
        return _TimeTagger.EventVectorVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.EventVectorVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.EventVectorVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< Event > >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.EventVectorVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _TimeTagger.EventVectorVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< Event > >::size_type"""
        return _TimeTagger.EventVectorVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_EventVectorVector

# Register EventVectorVector in _TimeTagger:
_TimeTagger.EventVectorVector_swigregister(EventVectorVector)

class IntVectorVector(object):
    r"""Proxy of C++ std::vector< std::vector< int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.IntVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.IntVectorVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.IntVectorVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< int > >::size_type"""
        return _TimeTagger.IntVectorVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> IntVectorVector"""
        return _TimeTagger.IntVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.IntVectorVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.IntVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.IntVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> IntVectorVector
        __getitem__(self, i) -> IntVector
        """
        return _TimeTagger.IntVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.IntVectorVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> IntVector"""
        return _TimeTagger.IntVectorVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.IntVectorVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.IntVectorVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< int > >::size_type"""
        return _TimeTagger.IntVectorVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.IntVectorVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< int > >::iterator"""
        return _TimeTagger.IntVectorVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< int > >::iterator"""
        return _TimeTagger.IntVectorVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< int > >::reverse_iterator"""
        return _TimeTagger.IntVectorVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< int > >::reverse_iterator"""
        return _TimeTagger.IntVectorVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.IntVectorVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< int > >::allocator_type"""
        return _TimeTagger.IntVectorVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.IntVectorVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< int > >::iterator
        erase(self, first, last) -> std::vector< std::vector< int > >::iterator
        """
        return _TimeTagger.IntVectorVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> IntVectorVector
        __init__(self, other) -> IntVectorVector
        __init__(self, size) -> IntVectorVector
        __init__(self, size, value) -> IntVectorVector
        """
        _TimeTagger.IntVectorVector_swiginit(self, _TimeTagger.new_IntVectorVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.IntVectorVector_push_back(self, x)

    def front(self):
        r"""front(self) -> IntVector"""
        return _TimeTagger.IntVectorVector_front(self)

    def back(self):
        r"""back(self) -> IntVector"""
        return _TimeTagger.IntVectorVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.IntVectorVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.IntVectorVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< int > >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.IntVectorVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _TimeTagger.IntVectorVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< int > >::size_type"""
        return _TimeTagger.IntVectorVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_IntVectorVector

# Register IntVectorVector in _TimeTagger:
_TimeTagger.IntVectorVector_swigregister(IntVectorVector)

class UIntVectorVector(object):
    r"""Proxy of C++ std::vector< std::vector< unsigned int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.UIntVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.UIntVectorVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _TimeTagger.UIntVectorVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< unsigned int > >::size_type"""
        return _TimeTagger.UIntVectorVector___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(self, i, j) -> UIntVectorVector"""
        return _TimeTagger.UIntVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.UIntVectorVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.UIntVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.UIntVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> UIntVectorVector
        __getitem__(self, i) -> UIntVector
        """
        return _TimeTagger.UIntVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.UIntVectorVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> UIntVector"""
        return _TimeTagger.UIntVectorVector_pop(self)

    def append(self, x):
        r"""append(self, x)"""
        return _TimeTagger.UIntVectorVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _TimeTagger.UIntVectorVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< unsigned int > >::size_type"""
        return _TimeTagger.UIntVectorVector_size(self)

    def swap(self, v):
        r"""swap(self, v)"""
        return _TimeTagger.UIntVectorVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< unsigned int > >::iterator"""
        return _TimeTagger.UIntVectorVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< unsigned int > >::iterator"""
        return _TimeTagger.UIntVectorVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< unsigned int > >::reverse_iterator"""
        return _TimeTagger.UIntVectorVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< unsigned int > >::reverse_iterator"""
        return _TimeTagger.UIntVectorVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.UIntVectorVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< unsigned int > >::allocator_type"""
        return _TimeTagger.UIntVectorVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _TimeTagger.UIntVectorVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< unsigned int > >::iterator
        erase(self, first, last) -> std::vector< std::vector< unsigned int > >::iterator
        """
        return _TimeTagger.UIntVectorVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> UIntVectorVector
        __init__(self, other) -> UIntVectorVector
        __init__(self, size) -> UIntVectorVector
        __init__(self, size, value) -> UIntVectorVector
        """
        _TimeTagger.UIntVectorVector_swiginit(self, _TimeTagger.new_UIntVectorVector(*args))

    def push_back(self, x):
        r"""push_back(self, x)"""
        return _TimeTagger.UIntVectorVector_push_back(self, x)

    def front(self):
        r"""front(self) -> UIntVector"""
        return _TimeTagger.UIntVectorVector_front(self)

    def back(self):
        r"""back(self) -> UIntVector"""
        return _TimeTagger.UIntVectorVector_back(self)

    def assign(self, n, x):
        r"""assign(self, n, x)"""
        return _TimeTagger.UIntVectorVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.UIntVectorVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< unsigned int > >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.UIntVectorVector_insert(self, *args)

    def reserve(self, n):
        r"""reserve(self, n)"""
        return _TimeTagger.UIntVectorVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< unsigned int > >::size_type"""
        return _TimeTagger.UIntVectorVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_UIntVectorVector

# Register UIntVectorVector in _TimeTagger:
_TimeTagger.UIntVectorVector_swigregister(UIntVectorVector)

TIMETAGGER_VERSION = _TimeTagger.TIMETAGGER_VERSION


def getVersion():
    r"""getVersion() -> std::string"""
    return _TimeTagger.getVersion()
Resolution_Standard = _TimeTagger.Resolution_Standard

Resolution_HighResA = _TimeTagger.Resolution_HighResA

Resolution_HighResB = _TimeTagger.Resolution_HighResB

Resolution_HighResC = _TimeTagger.Resolution_HighResC

ChannelEdge_All = _TimeTagger.ChannelEdge_All

ChannelEdge_Rising = _TimeTagger.ChannelEdge_Rising

ChannelEdge_Falling = _TimeTagger.ChannelEdge_Falling

ChannelEdge_HighResAll = _TimeTagger.ChannelEdge_HighResAll

ChannelEdge_HighResRising = _TimeTagger.ChannelEdge_HighResRising

ChannelEdge_HighResFalling = _TimeTagger.ChannelEdge_HighResFalling

ChannelEdge_StandardAll = _TimeTagger.ChannelEdge_StandardAll

ChannelEdge_StandardRising = _TimeTagger.ChannelEdge_StandardRising

ChannelEdge_StandardFalling = _TimeTagger.ChannelEdge_StandardFalling


def createTimeTagger(*args, **kwargs):
    r"""createTimeTagger(serial="", resolution=Standard) -> TimeTagger"""
    return _TimeTagger.createTimeTagger(*args, **kwargs)

def createTimeTaggerVirtual():
    r"""createTimeTaggerVirtual() -> TimeTaggerVirtual"""
    return _TimeTagger.createTimeTaggerVirtual()

def setCustomBitFileName(bitFileName):
    r"""setCustomBitFileName(bitFileName)"""
    return _TimeTagger.setCustomBitFileName(bitFileName)

def scanTimeTagger():
    r"""scanTimeTagger() -> StringVector"""
    return _TimeTagger.scanTimeTagger()

def getTimeTaggerModel(serial):
    r"""getTimeTaggerModel(serial) -> std::string"""
    return _TimeTagger.getTimeTaggerModel(serial)

def setTimeTaggerChannelNumberScheme(scheme):
    r"""setTimeTaggerChannelNumberScheme(scheme)"""
    return _TimeTagger.setTimeTaggerChannelNumberScheme(scheme)

def getTimeTaggerChannelNumberScheme():
    r"""getTimeTaggerChannelNumberScheme() -> int"""
    return _TimeTagger.getTimeTaggerChannelNumberScheme()

def hasTimeTaggerVirtualLicense():
    r"""hasTimeTaggerVirtualLicense() -> bool"""
    return _TimeTagger.hasTimeTaggerVirtualLicense()

def flashLicense(serial, license):
    r"""flashLicense(serial, license)"""
    return _TimeTagger.flashLicense(serial, license)

def extractLicenseInfo(license):
    r"""extractLicenseInfo(license) -> std::string"""
    return _TimeTagger.extractLicenseInfo(license)
LOGGER_ERROR = _TimeTagger.LOGGER_ERROR

LOGGER_WARNING = _TimeTagger.LOGGER_WARNING

LOGGER_INFO = _TimeTagger.LOGGER_INFO

class CustomLogger(object):
    r"""Proxy of C++ CustomLogger class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(self) -> CustomLogger"""
        if self.__class__ == CustomLogger:
            _self = None
        else:
            _self = self
        _TimeTagger.CustomLogger_swiginit(self, _TimeTagger.new_CustomLogger(_self, ))
    __swig_destroy__ = _TimeTagger.delete_CustomLogger

    def enable(self):
        r"""enable(self)"""
        return _TimeTagger.CustomLogger_enable(self)

    def disable(self):
        r"""disable(self)"""
        return _TimeTagger.CustomLogger_disable(self)

    def Log(self, level, msg):
        r"""Log(self, level, msg)"""
        return _TimeTagger.CustomLogger_Log(self, level, msg)
    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_CustomLogger(self)
        return weakref.proxy(self)

# Register CustomLogger in _TimeTagger:
_TimeTagger.CustomLogger_swigregister(CustomLogger)
cvar = _TimeTagger.cvar
CHANNEL_UNUSED = cvar.CHANNEL_UNUSED
CHANNEL_UNUSED_OLD = cvar.CHANNEL_UNUSED_OLD
TT_CHANNEL_NUMBER_SCHEME_AUTO = cvar.TT_CHANNEL_NUMBER_SCHEME_AUTO
TT_CHANNEL_NUMBER_SCHEME_ZERO = cvar.TT_CHANNEL_NUMBER_SCHEME_ZERO
TT_CHANNEL_NUMBER_SCHEME_ONE = cvar.TT_CHANNEL_NUMBER_SCHEME_ONE
TT_CHANNEL_RISING_AND_FALLING_EDGES = cvar.TT_CHANNEL_RISING_AND_FALLING_EDGES
TT_CHANNEL_RISING_EDGES = cvar.TT_CHANNEL_RISING_EDGES
TT_CHANNEL_FALLING_EDGES = cvar.TT_CHANNEL_FALLING_EDGES

class TimeTaggerBase(object):
    r"""Proxy of C++ TimeTaggerBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getFence(self, alloc_fence=True):
        r"""getFence(self, alloc_fence=True) -> unsigned int"""
        return _TimeTagger.TimeTaggerBase_getFence(self, alloc_fence)

    def __waitForFence(self, fence, timeout=-1):
        r"""__waitForFence(self, fence, timeout=-1) -> bool"""
        return _TimeTagger.TimeTaggerBase___waitForFence(self, fence, timeout)

    def __sync(self, timeout=-1):
        r"""__sync(self, timeout=-1) -> bool"""
        return _TimeTagger.TimeTaggerBase___sync(self, timeout)

    def getInvertedChannel(self, channel):
        r"""getInvertedChannel(self, channel) -> int"""
        return _TimeTagger.TimeTaggerBase_getInvertedChannel(self, channel)

    def isUnusedChannel(self, channel):
        r"""isUnusedChannel(self, channel) -> bool"""
        return _TimeTagger.TimeTaggerBase_isUnusedChannel(self, channel)

    def __getConfiguration(self):
        r"""__getConfiguration(self) -> std::string"""
        return _TimeTagger.TimeTaggerBase___getConfiguration(self)

    def setInputDelay(self, channel, delay):
        r"""setInputDelay(self, channel, delay)"""
        return _TimeTagger.TimeTaggerBase_setInputDelay(self, channel, delay)

    def setDelayHardware(self, channel, delay):
        r"""setDelayHardware(self, channel, delay)"""
        return _TimeTagger.TimeTaggerBase_setDelayHardware(self, channel, delay)

    def setDelaySoftware(self, channel, delay):
        r"""setDelaySoftware(self, channel, delay)"""
        return _TimeTagger.TimeTaggerBase_setDelaySoftware(self, channel, delay)

    def getInputDelay(self, channel):
        r"""getInputDelay(self, channel) -> long long"""
        return _TimeTagger.TimeTaggerBase_getInputDelay(self, channel)

    def getDelaySoftware(self, channel):
        r"""getDelaySoftware(self, channel) -> long long"""
        return _TimeTagger.TimeTaggerBase_getDelaySoftware(self, channel)

    def getDelayHardware(self, channel):
        r"""getDelayHardware(self, channel) -> long long"""
        return _TimeTagger.TimeTaggerBase_getDelayHardware(self, channel)

    def setDeadtime(self, channel, deadtime):
        r"""setDeadtime(self, channel, deadtime) -> long long"""
        return _TimeTagger.TimeTaggerBase_setDeadtime(self, channel, deadtime)

    def getDeadtime(self, channel):
        r"""getDeadtime(self, channel) -> long long"""
        return _TimeTagger.TimeTaggerBase_getDeadtime(self, channel)

    def setTestSignal(self, *args):
        r"""
        setTestSignal(self, channel, enabled)
        setTestSignal(self, channel, enabled)
        """
        return _TimeTagger.TimeTaggerBase_setTestSignal(self, *args)

    def getTestSignal(self, channel):
        r"""getTestSignal(self, channel) -> bool"""
        return _TimeTagger.TimeTaggerBase_getTestSignal(self, channel)

    def getOverflows(self):
        r"""getOverflows(self) -> long long"""
        return _TimeTagger.TimeTaggerBase_getOverflows(self)

    def clearOverflows(self):
        r"""clearOverflows(self)"""
        return _TimeTagger.TimeTaggerBase_clearOverflows(self)

    def getOverflowsAndClear(self):
        r"""getOverflowsAndClear(self) -> long long"""
        return _TimeTagger.TimeTaggerBase_getOverflowsAndClear(self)

    def sync(self, timeout=-1):
        r"""sync(self, timeout=-1) -> bool"""
        fence = self.getFence()
        return self.waitForFence(fence, timeout)


    def waitForFence(self, fence, timeout=-1):
        r"""waitForFence(self, fence, timeout=-1) -> bool"""
        return _timeout_handler(lambda t: self.__waitForFence(fence, t), timeout)


    def getConfiguration(self):
        r"""getConfiguration(self) -> json"""
        import json
        return json.loads(self.__getConfiguration())


    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register TimeTaggerBase in _TimeTagger:
_TimeTagger.TimeTaggerBase_swigregister(TimeTaggerBase)

class TimeTaggerVirtual(TimeTaggerBase):
    r"""Proxy of C++ TimeTaggerVirtual class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def replay(self, file, begin=0, duration=-1, queue=True):
        r"""replay(self, file, begin=0, duration=-1, queue=True) -> uint64_t"""
        return _TimeTagger.TimeTaggerVirtual_replay(self, file, begin, duration, queue)

    def stop(self):
        r"""stop(self)"""
        return _TimeTagger.TimeTaggerVirtual_stop(self)

    def reset(self):
        r"""reset(self)"""
        return _TimeTagger.TimeTaggerVirtual_reset(self)

    def __waitForCompletion(self, ID=0, timeout=-1):
        r"""__waitForCompletion(self, ID=0, timeout=-1) -> bool"""
        return _TimeTagger.TimeTaggerVirtual___waitForCompletion(self, ID, timeout)

    def setReplaySpeed(self, speed):
        r"""setReplaySpeed(self, speed)"""
        return _TimeTagger.TimeTaggerVirtual_setReplaySpeed(self, speed)

    def getReplaySpeed(self):
        r"""getReplaySpeed(self) -> double"""
        return _TimeTagger.TimeTaggerVirtual_getReplaySpeed(self)

    def setConditionalFilter(self, trigger, filtered):
        r"""setConditionalFilter(self, trigger, filtered)"""
        return _TimeTagger.TimeTaggerVirtual_setConditionalFilter(self, trigger, filtered)

    def clearConditionalFilter(self):
        r"""clearConditionalFilter(self)"""
        return _TimeTagger.TimeTaggerVirtual_clearConditionalFilter(self)

    def getConditionalFilterTrigger(self):
        r"""getConditionalFilterTrigger(self) -> IntVector"""
        return _TimeTagger.TimeTaggerVirtual_getConditionalFilterTrigger(self)

    def getConditionalFilterFiltered(self):
        r"""getConditionalFilterFiltered(self) -> IntVector"""
        return _TimeTagger.TimeTaggerVirtual_getConditionalFilterFiltered(self)

    def waitForCompletion(self, ID=0, timeout=-1):
        r"""waitForCompletion(self, ID=0, timeout=-1) -> bool"""
        return _timeout_handler(lambda t: self.__waitForCompletion(ID, t), timeout)

    __swig_destroy__ = _TimeTagger.delete_TimeTaggerVirtual

# Register TimeTaggerVirtual in _TimeTagger:
_TimeTagger.TimeTaggerVirtual_swigregister(TimeTaggerVirtual)

class TimeTagger(TimeTaggerBase):
    r"""Proxy of C++ TimeTagger class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def reset(self):
        r"""reset(self)"""
        return _TimeTagger.TimeTagger_reset(self)

    def setTestSignalDivider(self, divider):
        r"""setTestSignalDivider(self, divider)"""
        return _TimeTagger.TimeTagger_setTestSignalDivider(self, divider)

    def getTestSignalDivider(self):
        r"""getTestSignalDivider(self) -> int"""
        return _TimeTagger.TimeTagger_getTestSignalDivider(self)

    def setTriggerLevel(self, channel, voltage):
        r"""setTriggerLevel(self, channel, voltage)"""
        return _TimeTagger.TimeTagger_setTriggerLevel(self, channel, voltage)

    def getTriggerLevel(self, channel):
        r"""getTriggerLevel(self, channel) -> double"""
        return _TimeTagger.TimeTagger_getTriggerLevel(self, channel)

    def getHardwareDelayCompensation(self, channel):
        r"""getHardwareDelayCompensation(self, channel) -> long long"""
        return _TimeTagger.TimeTagger_getHardwareDelayCompensation(self, channel)

    def setInputMux(self, channel, mux_mode):
        r"""setInputMux(self, channel, mux_mode)"""
        return _TimeTagger.TimeTagger_setInputMux(self, channel, mux_mode)

    def getInputMux(self, channel):
        r"""getInputMux(self, channel) -> int"""
        return _TimeTagger.TimeTagger_getInputMux(self, channel)

    def setConditionalFilter(self, trigger, filtered, hardwareDelayCompensation=True):
        r"""setConditionalFilter(self, trigger, filtered, hardwareDelayCompensation=True)"""
        return _TimeTagger.TimeTagger_setConditionalFilter(self, trigger, filtered, hardwareDelayCompensation)

    def clearConditionalFilter(self):
        r"""clearConditionalFilter(self)"""
        return _TimeTagger.TimeTagger_clearConditionalFilter(self)

    def getConditionalFilterTrigger(self):
        r"""getConditionalFilterTrigger(self) -> IntVector"""
        return _TimeTagger.TimeTagger_getConditionalFilterTrigger(self)

    def getConditionalFilterFiltered(self):
        r"""getConditionalFilterFiltered(self) -> IntVector"""
        return _TimeTagger.TimeTagger_getConditionalFilterFiltered(self)

    def setNormalization(self, channel, state):
        r"""setNormalization(self, channel, state)"""
        return _TimeTagger.TimeTagger_setNormalization(self, channel, state)

    def getNormalization(self, channel):
        r"""getNormalization(self, channel) -> bool"""
        return _TimeTagger.TimeTagger_getNormalization(self, channel)

    def setHardwareBufferSize(self, size):
        r"""setHardwareBufferSize(self, size)"""
        return _TimeTagger.TimeTagger_setHardwareBufferSize(self, size)

    def getHardwareBufferSize(self):
        r"""getHardwareBufferSize(self) -> int"""
        return _TimeTagger.TimeTagger_getHardwareBufferSize(self)

    def setStreamBlockSize(self, max_events, max_latency):
        r"""setStreamBlockSize(self, max_events, max_latency)"""
        return _TimeTagger.TimeTagger_setStreamBlockSize(self, max_events, max_latency)

    def getStreamBlockSizeEvents(self):
        r"""getStreamBlockSizeEvents(self) -> int"""
        return _TimeTagger.TimeTagger_getStreamBlockSizeEvents(self)

    def getStreamBlockSizeLatency(self):
        r"""getStreamBlockSizeLatency(self) -> int"""
        return _TimeTagger.TimeTagger_getStreamBlockSizeLatency(self)

    def setEventDivider(self, channel, divider):
        r"""setEventDivider(self, channel, divider)"""
        return _TimeTagger.TimeTagger_setEventDivider(self, channel, divider)

    def getEventDivider(self, channel):
        r"""getEventDivider(self, channel) -> unsigned int"""
        return _TimeTagger.TimeTagger_getEventDivider(self, channel)

    def autoCalibration(self):
        r"""autoCalibration(self)"""
        return _TimeTagger.TimeTagger_autoCalibration(self)

    def getSerial(self):
        r"""getSerial(self) -> std::string"""
        return _TimeTagger.TimeTagger_getSerial(self)

    def getModel(self):
        r"""getModel(self) -> std::string"""
        return _TimeTagger.TimeTagger_getModel(self)

    def getChannelNumberScheme(self):
        r"""getChannelNumberScheme(self) -> int"""
        return _TimeTagger.TimeTagger_getChannelNumberScheme(self)

    def getDACRange(self):
        r"""getDACRange(self) -> DoubleVector"""
        return _TimeTagger.TimeTagger_getDACRange(self)

    def getDistributionCount(self):
        r"""getDistributionCount(self)"""
        return _TimeTagger.TimeTagger_getDistributionCount(self)

    def getDistributionPSecs(self):
        r"""getDistributionPSecs(self)"""
        return _TimeTagger.TimeTagger_getDistributionPSecs(self)

    def getChannelList(self, *args, **kwargs):
        r"""getChannelList(self, type=All) -> IntVector"""
        return _TimeTagger.TimeTagger_getChannelList(self, *args, **kwargs)

    def getPsPerClock(self):
        r"""getPsPerClock(self) -> long long"""
        return _TimeTagger.TimeTagger_getPsPerClock(self)

    def getPcbVersion(self):
        r"""getPcbVersion(self) -> std::string"""
        return _TimeTagger.TimeTagger_getPcbVersion(self)

    def getFirmwareVersion(self):
        r"""getFirmwareVersion(self) -> std::string"""
        return _TimeTagger.TimeTagger_getFirmwareVersion(self)

    def __getSensorData(self):
        r"""__getSensorData(self) -> std::string"""
        return _TimeTagger.TimeTagger___getSensorData(self)

    def setLED(self, bitmask):
        r"""setLED(self, bitmask)"""
        return _TimeTagger.TimeTagger_setLED(self, bitmask)

    def getLicenseInfo(self):
        r"""getLicenseInfo(self) -> std::string"""
        return _TimeTagger.TimeTagger_getLicenseInfo(self)

    def factoryAccess(self, pw, addr, data, mask):
        r"""factoryAccess(self, pw, addr, data, mask) -> uint32_t"""
        return _TimeTagger.TimeTagger_factoryAccess(self, pw, addr, data, mask)

    def setSoundFrequency(self, freq_hz):
        r"""setSoundFrequency(self, freq_hz)"""
        return _TimeTagger.TimeTagger_setSoundFrequency(self, freq_hz)

    def getSensorData(self):
        r"""getSensorData(self) -> json"""
        import json
        return json.loads(self.__getSensorData())

    __swig_destroy__ = _TimeTagger.delete_TimeTagger

# Register TimeTagger in _TimeTagger:
_TimeTagger.TimeTagger_swigregister(TimeTagger)

class IteratorBase(object):
    r"""Proxy of C++ IteratorBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_IteratorBase

    def start(self):
        r"""start(self)"""
        return _TimeTagger.IteratorBase_start(self)

    def startFor(self, capture_duration, clear=True):
        r"""startFor(self, capture_duration, clear=True)"""
        return _TimeTagger.IteratorBase_startFor(self, capture_duration, clear)

    def __waitUntilFinished(self, timeout=-1):
        r"""__waitUntilFinished(self, timeout=-1) -> bool"""
        return _TimeTagger.IteratorBase___waitUntilFinished(self, timeout)

    def stop(self):
        r"""stop(self)"""
        return _TimeTagger.IteratorBase_stop(self)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.IteratorBase_clear(self)

    def isRunning(self):
        r"""isRunning(self) -> bool"""
        return _TimeTagger.IteratorBase_isRunning(self)

    def getCaptureDuration(self):
        r"""getCaptureDuration(self) -> long long"""
        return _TimeTagger.IteratorBase_getCaptureDuration(self)

    def waitUntilFinished(self, timeout=-1):
        r"""waitUntilFinished(self, timeout=-1) -> bool"""
        return _timeout_handler(self.__waitUntilFinished, timeout)


    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register IteratorBase in _TimeTagger:
_TimeTagger.IteratorBase_swigregister(IteratorBase)

LanguageUsed_Cpp = _TimeTagger.LanguageUsed_Cpp

LanguageUsed_Python = _TimeTagger.LanguageUsed_Python

LanguageUsed_Csharp = _TimeTagger.LanguageUsed_Csharp

LanguageUsed_Matlab = _TimeTagger.LanguageUsed_Matlab

LanguageUsed_Labview = _TimeTagger.LanguageUsed_Labview

LanguageUsed_Mathematica = _TimeTagger.LanguageUsed_Mathematica

LanguageUsed_Unknown = _TimeTagger.LanguageUsed_Unknown

FrontendType_Undefined = _TimeTagger.FrontendType_Undefined

FrontendType_WebApp = _TimeTagger.FrontendType_WebApp

FrontendType_Firefly = _TimeTagger.FrontendType_Firefly

FrontendType_Pyro5RPC = _TimeTagger.FrontendType_Pyro5RPC

FrontendType_UserFrontend = _TimeTagger.FrontendType_UserFrontend


def setLanguageInfo(pw, language, version):
    r"""setLanguageInfo(pw, language, version)"""
    return _TimeTagger.setLanguageInfo(pw, language, version)

def setFrontend(frontend):
    r"""setFrontend(frontend)"""
    return _TimeTagger.setFrontend(frontend)
UsageStatisticsStatus_Disabled = _TimeTagger.UsageStatisticsStatus_Disabled

UsageStatisticsStatus_Collecting = _TimeTagger.UsageStatisticsStatus_Collecting

UsageStatisticsStatus_CollectingAndUploading = _TimeTagger.UsageStatisticsStatus_CollectingAndUploading


def setUsageStatisticsStatus(new_status):
    r"""setUsageStatisticsStatus(new_status)"""
    return _TimeTagger.setUsageStatisticsStatus(new_status)

def getUsageStatisticsStatus():
    r"""getUsageStatisticsStatus() -> UsageStatisticsStatus"""
    return _TimeTagger.getUsageStatisticsStatus()

def getUsageStatisticsReport():
    r"""getUsageStatisticsReport() -> std::string"""
    return _TimeTagger.getUsageStatisticsReport()
class Combiner(IteratorBase):
    r"""Proxy of C++ Combiner class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, channels):
        r"""__init__(self, tagger, channels) -> Combiner"""
        _TimeTagger.Combiner_swiginit(self, _TimeTagger.new_Combiner(tagger, channels))
    __swig_destroy__ = _TimeTagger.delete_Combiner

    def getData(self):
        r"""getData(self)"""
        return _TimeTagger.Combiner_getData(self)

    def getChannel(self):
        r"""getChannel(self) -> int"""
        return _TimeTagger.Combiner_getChannel(self)

# Register Combiner in _TimeTagger:
_TimeTagger.Combiner_swigregister(Combiner)

class CountBetweenMarkers(IteratorBase):
    r"""Proxy of C++ CountBetweenMarkers class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, click_channel, begin_channel, end_channel=CHANNEL_UNUSED, n_values=1000) -> CountBetweenMarkers"""
        _TimeTagger.CountBetweenMarkers_swiginit(self, _TimeTagger.new_CountBetweenMarkers(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_CountBetweenMarkers

    def ready(self):
        r"""ready(self) -> bool"""
        return _TimeTagger.CountBetweenMarkers_ready(self)

    def getData(self):
        r"""getData(self)"""
        return _TimeTagger.CountBetweenMarkers_getData(self)

    def getBinWidths(self):
        r"""getBinWidths(self)"""
        return _TimeTagger.CountBetweenMarkers_getBinWidths(self)

    def getIndex(self):
        r"""getIndex(self)"""
        return _TimeTagger.CountBetweenMarkers_getIndex(self)

# Register CountBetweenMarkers in _TimeTagger:
_TimeTagger.CountBetweenMarkers_swigregister(CountBetweenMarkers)

class Counter(IteratorBase):
    r"""Proxy of C++ Counter class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, channels, binwidth=1000000000, n_values=1):
        r"""__init__(self, tagger, channels, binwidth=1000000000, n_values=1) -> Counter"""
        _TimeTagger.Counter_swiginit(self, _TimeTagger.new_Counter(tagger, channels, binwidth, n_values))
    __swig_destroy__ = _TimeTagger.delete_Counter

    def getData(self):
        r"""getData(self)"""
        return _TimeTagger.Counter_getData(self)

    def getIndex(self):
        r"""getIndex(self)"""
        return _TimeTagger.Counter_getIndex(self)

# Register Counter in _TimeTagger:
_TimeTagger.Counter_swigregister(Counter)

CoincidenceTimestamp_Last = _TimeTagger.CoincidenceTimestamp_Last

CoincidenceTimestamp_Average = _TimeTagger.CoincidenceTimestamp_Average

CoincidenceTimestamp_First = _TimeTagger.CoincidenceTimestamp_First

CoincidenceTimestamp_ListedFirst = _TimeTagger.CoincidenceTimestamp_ListedFirst

class Coincidences(IteratorBase):
    r"""Proxy of C++ Coincidences class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, coincidenceGroups, coincidenceWindow, timestamp=Last) -> Coincidences"""
        _TimeTagger.Coincidences_swiginit(self, _TimeTagger.new_Coincidences(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Coincidences

    def getChannels(self):
        r"""getChannels(self) -> IntVector"""
        return _TimeTagger.Coincidences_getChannels(self)

    def setCoincidenceWindow(self, coincidenceWindow):
        r"""setCoincidenceWindow(self, coincidenceWindow)"""
        return _TimeTagger.Coincidences_setCoincidenceWindow(self, coincidenceWindow)

# Register Coincidences in _TimeTagger:
_TimeTagger.Coincidences_swigregister(Coincidences)

class Coincidence(Coincidences):
    r"""Proxy of C++ Coincidence class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, channels, coincidenceWindow=1000, timestamp=Last) -> Coincidence"""
        _TimeTagger.Coincidence_swiginit(self, _TimeTagger.new_Coincidence(*args, **kwargs))

    def getChannel(self):
        r"""getChannel(self) -> int"""
        return _TimeTagger.Coincidence_getChannel(self)
    __swig_destroy__ = _TimeTagger.delete_Coincidence

# Register Coincidence in _TimeTagger:
_TimeTagger.Coincidence_swigregister(Coincidence)

class Countrate(IteratorBase):
    r"""Proxy of C++ Countrate class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, channels):
        r"""__init__(self, tagger, channels) -> Countrate"""
        _TimeTagger.Countrate_swiginit(self, _TimeTagger.new_Countrate(tagger, channels))
    __swig_destroy__ = _TimeTagger.delete_Countrate

    def getData(self):
        r"""getData(self)"""
        return _TimeTagger.Countrate_getData(self)

    def getCountsTotal(self):
        r"""getCountsTotal(self)"""
        return _TimeTagger.Countrate_getCountsTotal(self)

# Register Countrate in _TimeTagger:
_TimeTagger.Countrate_swigregister(Countrate)

class DelayedChannel(IteratorBase):
    r"""Proxy of C++ DelayedChannel class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, input_channel, delay):
        r"""__init__(self, tagger, input_channel, delay) -> DelayedChannel"""
        _TimeTagger.DelayedChannel_swiginit(self, _TimeTagger.new_DelayedChannel(tagger, input_channel, delay))
    __swig_destroy__ = _TimeTagger.delete_DelayedChannel

    def getChannel(self):
        r"""getChannel(self) -> int"""
        return _TimeTagger.DelayedChannel_getChannel(self)

    def setDelay(self, delay):
        r"""setDelay(self, delay)"""
        return _TimeTagger.DelayedChannel_setDelay(self, delay)

# Register DelayedChannel in _TimeTagger:
_TimeTagger.DelayedChannel_swigregister(DelayedChannel)

class TriggerOnCountrate(IteratorBase):
    r"""Proxy of C++ TriggerOnCountrate class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, input_channel, reference_countrate, hysteresis, time_window):
        r"""__init__(self, tagger, input_channel, reference_countrate, hysteresis, time_window) -> TriggerOnCountrate"""
        _TimeTagger.TriggerOnCountrate_swiginit(self, _TimeTagger.new_TriggerOnCountrate(tagger, input_channel, reference_countrate, hysteresis, time_window))
    __swig_destroy__ = _TimeTagger.delete_TriggerOnCountrate

    def getChannelAbove(self):
        r"""getChannelAbove(self) -> int"""
        return _TimeTagger.TriggerOnCountrate_getChannelAbove(self)

    def getChannelBelow(self):
        r"""getChannelBelow(self) -> int"""
        return _TimeTagger.TriggerOnCountrate_getChannelBelow(self)

    def getChannels(self):
        r"""getChannels(self) -> IntVector"""
        return _TimeTagger.TriggerOnCountrate_getChannels(self)

    def isAbove(self):
        r"""isAbove(self) -> bool"""
        return _TimeTagger.TriggerOnCountrate_isAbove(self)

    def isBelow(self):
        r"""isBelow(self) -> bool"""
        return _TimeTagger.TriggerOnCountrate_isBelow(self)

    def getCurrentCountrate(self):
        r"""getCurrentCountrate(self) -> double"""
        return _TimeTagger.TriggerOnCountrate_getCurrentCountrate(self)

    def injectCurrentState(self):
        r"""injectCurrentState(self) -> bool"""
        return _TimeTagger.TriggerOnCountrate_injectCurrentState(self)

# Register TriggerOnCountrate in _TimeTagger:
_TimeTagger.TriggerOnCountrate_swigregister(TriggerOnCountrate)

class GatedChannel(IteratorBase):
    r"""Proxy of C++ GatedChannel class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, input_channel, gate_start_channel, gate_stop_channel):
        r"""__init__(self, tagger, input_channel, gate_start_channel, gate_stop_channel) -> GatedChannel"""
        _TimeTagger.GatedChannel_swiginit(self, _TimeTagger.new_GatedChannel(tagger, input_channel, gate_start_channel, gate_stop_channel))
    __swig_destroy__ = _TimeTagger.delete_GatedChannel

    def getChannel(self):
        r"""getChannel(self) -> int"""
        return _TimeTagger.GatedChannel_getChannel(self)

# Register GatedChannel in _TimeTagger:
_TimeTagger.GatedChannel_swigregister(GatedChannel)

class FrequencyMultiplier(IteratorBase):
    r"""Proxy of C++ FrequencyMultiplier class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, input_channel, multiplier):
        r"""__init__(self, tagger, input_channel, multiplier) -> FrequencyMultiplier"""
        _TimeTagger.FrequencyMultiplier_swiginit(self, _TimeTagger.new_FrequencyMultiplier(tagger, input_channel, multiplier))
    __swig_destroy__ = _TimeTagger.delete_FrequencyMultiplier

    def getChannel(self):
        r"""getChannel(self) -> int"""
        return _TimeTagger.FrequencyMultiplier_getChannel(self)

    def getMultiplier(self):
        r"""getMultiplier(self) -> int32_t"""
        return _TimeTagger.FrequencyMultiplier_getMultiplier(self)

# Register FrequencyMultiplier in _TimeTagger:
_TimeTagger.FrequencyMultiplier_swigregister(FrequencyMultiplier)

class Iterator(IteratorBase):
    r"""Proxy of C++ Iterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, channel):
        r"""__init__(self, tagger, channel) -> Iterator"""
        _TimeTagger.Iterator_swiginit(self, _TimeTagger.new_Iterator(tagger, channel))
    __swig_destroy__ = _TimeTagger.delete_Iterator

    def next(self):
        r"""next(self) -> long long"""
        return _TimeTagger.Iterator_next(self)

    def size(self):
        r"""size(self) -> uint64_t"""
        return _TimeTagger.Iterator_size(self)

# Register Iterator in _TimeTagger:
_TimeTagger.Iterator_swigregister(Iterator)

class TimeTagStreamBuffer(object):
    r"""Proxy of C++ TimeTagStreamBuffer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getOverflows(self):
        r"""getOverflows(self)"""
        return _TimeTagger.TimeTagStreamBuffer_getOverflows(self)

    def getChannels(self):
        r"""getChannels(self)"""
        return _TimeTagger.TimeTagStreamBuffer_getChannels(self)

    def getTimestamps(self):
        r"""getTimestamps(self)"""
        return _TimeTagger.TimeTagStreamBuffer_getTimestamps(self)

    def getMissedEvents(self):
        r"""getMissedEvents(self)"""
        return _TimeTagger.TimeTagStreamBuffer_getMissedEvents(self)

    def getEventTypes(self):
        r"""getEventTypes(self)"""
        return _TimeTagger.TimeTagStreamBuffer_getEventTypes(self)
    size = property(_TimeTagger.TimeTagStreamBuffer_size_get, _TimeTagger.TimeTagStreamBuffer_size_set, doc=r"""size""")
    hasOverflows = property(_TimeTagger.TimeTagStreamBuffer_hasOverflows_get, _TimeTagger.TimeTagStreamBuffer_hasOverflows_set, doc=r"""hasOverflows""")
    tStart = property(_TimeTagger.TimeTagStreamBuffer_tStart_get, _TimeTagger.TimeTagStreamBuffer_tStart_set, doc=r"""tStart""")
    tGetData = property(_TimeTagger.TimeTagStreamBuffer_tGetData_get, _TimeTagger.TimeTagStreamBuffer_tGetData_set, doc=r"""tGetData""")

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


    def __init__(self):
        r"""__init__(self) -> TimeTagStreamBuffer"""
        _TimeTagger.TimeTagStreamBuffer_swiginit(self, _TimeTagger.new_TimeTagStreamBuffer())
    __swig_destroy__ = _TimeTagger.delete_TimeTagStreamBuffer

# Register TimeTagStreamBuffer in _TimeTagger:
_TimeTagger.TimeTagStreamBuffer_swigregister(TimeTagStreamBuffer)

class TimeTagStream(IteratorBase):
    r"""Proxy of C++ TimeTagStream class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, n_max_events, channels=std::vector< int >()) -> TimeTagStream"""
        _TimeTagger.TimeTagStream_swiginit(self, _TimeTagger.new_TimeTagStream(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_TimeTagStream

    def getCounts(self):
        r"""getCounts(self) -> uint64_t"""
        return _TimeTagger.TimeTagStream_getCounts(self)

    def getData(self):
        r"""getData(self) -> TimeTagStreamBuffer"""
        return _TimeTagger.TimeTagStream_getData(self)

# Register TimeTagStream in _TimeTagger:
_TimeTagger.TimeTagStream_swigregister(TimeTagStream)

class Dump(IteratorBase):
    r"""Proxy of C++ Dump class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, filename, max_tags, channels=std::vector< int >()) -> Dump"""
        _TimeTagger.Dump_swiginit(self, _TimeTagger.new_Dump(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Dump

# Register Dump in _TimeTagger:
_TimeTagger.Dump_swigregister(Dump)

class StartStop(IteratorBase):
    r"""Proxy of C++ StartStop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, click_channel, start_channel=CHANNEL_UNUSED, binwidth=1000) -> StartStop"""
        _TimeTagger.StartStop_swiginit(self, _TimeTagger.new_StartStop(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_StartStop

    def getData(self):
        r"""getData(self)"""
        return _TimeTagger.StartStop_getData(self)

# Register StartStop in _TimeTagger:
_TimeTagger.StartStop_swigregister(StartStop)

class TimeDifferences(IteratorBase):
    r"""Proxy of C++ TimeDifferences class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, click_channel, start_channel=CHANNEL_UNUSED, next_channel=CHANNEL_UNUSED, sync_channel=CHANNEL_UNUSED, binwidth=1000, n_bins=1000, n_histograms=1) -> TimeDifferences"""
        _TimeTagger.TimeDifferences_swiginit(self, _TimeTagger.new_TimeDifferences(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_TimeDifferences

    def getData(self):
        r"""getData(self)"""
        return _TimeTagger.TimeDifferences_getData(self)

    def getIndex(self):
        r"""getIndex(self)"""
        return _TimeTagger.TimeDifferences_getIndex(self)

    def setMaxCounts(self, max_counts):
        r"""setMaxCounts(self, max_counts)"""
        return _TimeTagger.TimeDifferences_setMaxCounts(self, max_counts)

    def getCounts(self):
        r"""getCounts(self) -> uint64_t"""
        return _TimeTagger.TimeDifferences_getCounts(self)

    def ready(self):
        r"""ready(self) -> bool"""
        return _TimeTagger.TimeDifferences_ready(self)

# Register TimeDifferences in _TimeTagger:
_TimeTagger.TimeDifferences_swigregister(TimeDifferences)

class Histogram2D(IteratorBase):
    r"""Proxy of C++ Histogram2D class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, start_channel, stop_channel_1, stop_channel_2, binwidth_1, binwidth_2, n_bins_1, n_bins_2):
        r"""__init__(self, tagger, start_channel, stop_channel_1, stop_channel_2, binwidth_1, binwidth_2, n_bins_1, n_bins_2) -> Histogram2D"""
        _TimeTagger.Histogram2D_swiginit(self, _TimeTagger.new_Histogram2D(tagger, start_channel, stop_channel_1, stop_channel_2, binwidth_1, binwidth_2, n_bins_1, n_bins_2))
    __swig_destroy__ = _TimeTagger.delete_Histogram2D

    def getData(self):
        r"""getData(self)"""
        return _TimeTagger.Histogram2D_getData(self)

    def getIndex(self):
        r"""getIndex(self)"""
        return _TimeTagger.Histogram2D_getIndex(self)

    def getIndex_1(self):
        r"""getIndex_1(self)"""
        return _TimeTagger.Histogram2D_getIndex_1(self)

    def getIndex_2(self):
        r"""getIndex_2(self)"""
        return _TimeTagger.Histogram2D_getIndex_2(self)

# Register Histogram2D in _TimeTagger:
_TimeTagger.Histogram2D_swigregister(Histogram2D)

class TimeDifferencesND(IteratorBase):
    r"""Proxy of C++ TimeDifferencesND class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, click_channel, start_channel, next_channels, sync_channels, n_histograms, binwidth, n_bins):
        r"""__init__(self, tagger, click_channel, start_channel, next_channels, sync_channels, n_histograms, binwidth, n_bins) -> TimeDifferencesND"""
        _TimeTagger.TimeDifferencesND_swiginit(self, _TimeTagger.new_TimeDifferencesND(tagger, click_channel, start_channel, next_channels, sync_channels, n_histograms, binwidth, n_bins))
    __swig_destroy__ = _TimeTagger.delete_TimeDifferencesND

    def getData(self):
        r"""getData(self)"""
        return _TimeTagger.TimeDifferencesND_getData(self)

    def getIndex(self):
        r"""getIndex(self)"""
        return _TimeTagger.TimeDifferencesND_getIndex(self)

# Register TimeDifferencesND in _TimeTagger:
_TimeTagger.TimeDifferencesND_swigregister(TimeDifferencesND)

class Histogram(IteratorBase):
    r"""Proxy of C++ Histogram class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, click_channel, start_channel=CHANNEL_UNUSED, binwidth=1000, n_bins=1000) -> Histogram"""
        _TimeTagger.Histogram_swiginit(self, _TimeTagger.new_Histogram(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Histogram

    def getData(self):
        r"""getData(self)"""
        return _TimeTagger.Histogram_getData(self)

    def getIndex(self):
        r"""getIndex(self)"""
        return _TimeTagger.Histogram_getIndex(self)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register Histogram in _TimeTagger:
_TimeTagger.Histogram_swigregister(Histogram)

class HistogramLogBins(IteratorBase):
    r"""Proxy of C++ HistogramLogBins class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, click_channel, start_channel, exp_start, exp_stop, n_bins):
        r"""__init__(self, tagger, click_channel, start_channel, exp_start, exp_stop, n_bins) -> HistogramLogBins"""
        _TimeTagger.HistogramLogBins_swiginit(self, _TimeTagger.new_HistogramLogBins(tagger, click_channel, start_channel, exp_start, exp_stop, n_bins))
    __swig_destroy__ = _TimeTagger.delete_HistogramLogBins

    def getData(self):
        r"""getData(self)"""
        return _TimeTagger.HistogramLogBins_getData(self)

    def getDataNormalizedCountsPerPs(self):
        r"""getDataNormalizedCountsPerPs(self)"""
        return _TimeTagger.HistogramLogBins_getDataNormalizedCountsPerPs(self)

    def getDataNormalizedG2(self):
        r"""getDataNormalizedG2(self)"""
        return _TimeTagger.HistogramLogBins_getDataNormalizedG2(self)

    def getBinEdges(self):
        r"""getBinEdges(self)"""
        return _TimeTagger.HistogramLogBins_getBinEdges(self)

# Register HistogramLogBins in _TimeTagger:
_TimeTagger.HistogramLogBins_swigregister(HistogramLogBins)

class Correlation(IteratorBase):
    r"""Proxy of C++ Correlation class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, channel_1, channel_2=CHANNEL_UNUSED, binwidth=1000, n_bins=1000) -> Correlation"""
        _TimeTagger.Correlation_swiginit(self, _TimeTagger.new_Correlation(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Correlation

    def getData(self):
        r"""getData(self)"""
        return _TimeTagger.Correlation_getData(self)

    def getDataNormalized(self):
        r"""getDataNormalized(self)"""
        return _TimeTagger.Correlation_getDataNormalized(self)

    def getIndex(self):
        r"""getIndex(self)"""
        return _TimeTagger.Correlation_getIndex(self)

# Register Correlation in _TimeTagger:
_TimeTagger.Correlation_swigregister(Correlation)

UNKNOWN = _TimeTagger.UNKNOWN

HIGH = _TimeTagger.HIGH

LOW = _TimeTagger.LOW

class Event(object):
    r"""Proxy of C++ Event class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    time = property(_TimeTagger.Event_time_get, _TimeTagger.Event_time_set, doc=r"""time""")
    state = property(_TimeTagger.Event_state_get, _TimeTagger.Event_state_set, doc=r"""state""")

    def __init__(self):
        r"""__init__(self) -> Event"""
        _TimeTagger.Event_swiginit(self, _TimeTagger.new_Event())
    __swig_destroy__ = _TimeTagger.delete_Event

# Register Event in _TimeTagger:
_TimeTagger.Event_swigregister(Event)

class Scope(IteratorBase):
    r"""Proxy of C++ Scope class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, event_channels, trigger_channel, window_size=1000000000, n_traces=1, n_max_events=1000):
        r"""__init__(self, tagger, event_channels, trigger_channel, window_size=1000000000, n_traces=1, n_max_events=1000) -> Scope"""
        _TimeTagger.Scope_swiginit(self, _TimeTagger.new_Scope(tagger, event_channels, trigger_channel, window_size, n_traces, n_max_events))
    __swig_destroy__ = _TimeTagger.delete_Scope

    def ready(self):
        r"""ready(self) -> bool"""
        return _TimeTagger.Scope_ready(self)

    def triggered(self):
        r"""triggered(self) -> int32_t"""
        return _TimeTagger.Scope_triggered(self)

    def getData(self):
        r"""getData(self) -> EventVectorVector"""
        return _TimeTagger.Scope_getData(self)

    def getWindowSize(self):
        r"""getWindowSize(self) -> long long"""
        return _TimeTagger.Scope_getWindowSize(self)

# Register Scope in _TimeTagger:
_TimeTagger.Scope_swigregister(Scope)

class SynchronizedMeasurements(object):
    r"""Proxy of C++ SynchronizedMeasurements class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger):
        r"""__init__(self, tagger) -> SynchronizedMeasurements"""
        _TimeTagger.SynchronizedMeasurements_swiginit(self, _TimeTagger.new_SynchronizedMeasurements(tagger))
    __swig_destroy__ = _TimeTagger.delete_SynchronizedMeasurements

    def registerMeasurement(self, measurement):
        r"""registerMeasurement(self, measurement)"""
        return _TimeTagger.SynchronizedMeasurements_registerMeasurement(self, measurement)

    def unregisterMeasurement(self, measurement):
        r"""unregisterMeasurement(self, measurement)"""
        return _TimeTagger.SynchronizedMeasurements_unregisterMeasurement(self, measurement)

    def clear(self):
        r"""clear(self)"""
        return _TimeTagger.SynchronizedMeasurements_clear(self)

    def start(self):
        r"""start(self)"""
        return _TimeTagger.SynchronizedMeasurements_start(self)

    def stop(self):
        r"""stop(self)"""
        return _TimeTagger.SynchronizedMeasurements_stop(self)

    def startFor(self, capture_duration, clear=True):
        r"""startFor(self, capture_duration, clear=True)"""
        return _TimeTagger.SynchronizedMeasurements_startFor(self, capture_duration, clear)

    def __waitUntilFinished(self, timeout=-1):
        r"""__waitUntilFinished(self, timeout=-1) -> bool"""
        return _TimeTagger.SynchronizedMeasurements___waitUntilFinished(self, timeout)

    def isRunning(self):
        r"""isRunning(self) -> bool"""
        return _TimeTagger.SynchronizedMeasurements_isRunning(self)

    def getTagger(self):
        r"""getTagger(self) -> TimeTaggerBase"""
        return _TimeTagger.SynchronizedMeasurements_getTagger(self)

    def waitUntilFinished(self, timeout=-1):
        r"""waitUntilFinished(self, timeout=-1) -> bool"""
        return _timeout_handler(self.__waitUntilFinished, timeout)


    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register SynchronizedMeasurements in _TimeTagger:
_TimeTagger.SynchronizedMeasurements_swigregister(SynchronizedMeasurements)

class ConstantFractionDiscriminator(IteratorBase):
    r"""Proxy of C++ ConstantFractionDiscriminator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, channels, search_window):
        r"""__init__(self, tagger, channels, search_window) -> ConstantFractionDiscriminator"""
        _TimeTagger.ConstantFractionDiscriminator_swiginit(self, _TimeTagger.new_ConstantFractionDiscriminator(tagger, channels, search_window))
    __swig_destroy__ = _TimeTagger.delete_ConstantFractionDiscriminator

    def getChannels(self):
        r"""getChannels(self) -> IntVector"""
        return _TimeTagger.ConstantFractionDiscriminator_getChannels(self)

# Register ConstantFractionDiscriminator in _TimeTagger:
_TimeTagger.ConstantFractionDiscriminator_swigregister(ConstantFractionDiscriminator)

class FileWriter(IteratorBase):
    r"""Proxy of C++ FileWriter class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger, filename, channels):
        r"""__init__(self, tagger, filename, channels) -> FileWriter"""
        _TimeTagger.FileWriter_swiginit(self, _TimeTagger.new_FileWriter(tagger, filename, channels))
    __swig_destroy__ = _TimeTagger.delete_FileWriter

    def split(self, *args, **kwargs):
        r"""split(self, new_filename="")"""
        return _TimeTagger.FileWriter_split(self, *args, **kwargs)

    def setMaxFileSize(self, max_file_size):
        r"""setMaxFileSize(self, max_file_size)"""
        return _TimeTagger.FileWriter_setMaxFileSize(self, max_file_size)

    def getMaxFileSize(self):
        r"""getMaxFileSize(self) -> uint64_t"""
        return _TimeTagger.FileWriter_getMaxFileSize(self)

    def getTotalEvents(self):
        r"""getTotalEvents(self) -> uint64_t"""
        return _TimeTagger.FileWriter_getTotalEvents(self)

    def getTotalSize(self):
        r"""getTotalSize(self) -> uint64_t"""
        return _TimeTagger.FileWriter_getTotalSize(self)

    def setMarker(self, marker):
        r"""setMarker(self, marker)"""
        return _TimeTagger.FileWriter_setMarker(self, marker)

# Register FileWriter in _TimeTagger:
_TimeTagger.FileWriter_swigregister(FileWriter)

class FileReader(object):
    r"""Proxy of C++ FileReader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, filenames) -> FileReader
        __init__(self, filename) -> FileReader
        """
        _TimeTagger.FileReader_swiginit(self, _TimeTagger.new_FileReader(*args))
    __swig_destroy__ = _TimeTagger.delete_FileReader

    def hasData(self):
        r"""hasData(self) -> bool"""
        return _TimeTagger.FileReader_hasData(self)

    def getData(self, n_events):
        r"""getData(self, n_events) -> TimeTagStreamBuffer"""
        return _TimeTagger.FileReader_getData(self, n_events)

    def __getConfiguration(self):
        r"""__getConfiguration(self) -> std::string"""
        return _TimeTagger.FileReader___getConfiguration(self)

    def getLastMarker(self):
        r"""getLastMarker(self) -> std::string"""
        return _TimeTagger.FileReader_getLastMarker(self)

    def getConfiguration(self):
        r"""getConfiguration(self) -> json"""
        import json
        return json.loads(self.__getConfiguration())


    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register FileReader in _TimeTagger:
_TimeTagger.FileReader_swigregister(FileReader)

class EventGenerator(IteratorBase):
    r"""Proxy of C++ EventGenerator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, trigger_channel, pattern, trigger_divider=1, divider_offset=0, stop_channel=CHANNEL_UNUSED) -> EventGenerator"""
        _TimeTagger.EventGenerator_swiginit(self, _TimeTagger.new_EventGenerator(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_EventGenerator

    def getChannel(self):
        r"""getChannel(self) -> int"""
        return _TimeTagger.EventGenerator_getChannel(self)

# Register EventGenerator in _TimeTagger:
_TimeTagger.EventGenerator_swigregister(EventGenerator)

class CustomMeasurementBase(IteratorBase):
    r"""Proxy of C++ CustomMeasurementBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger):
        r"""__init__(self, tagger) -> CustomMeasurementBase"""
        if self.__class__ == CustomMeasurementBase:
            _self = None
        else:
            _self = self
        _TimeTagger.CustomMeasurementBase_swiginit(self, _TimeTagger.new_CustomMeasurementBase(_self, tagger))
    __swig_destroy__ = _TimeTagger.delete_CustomMeasurementBase

    @staticmethod
    def stop_all_custom_measurements():
        r"""stop_all_custom_measurements()"""
        return _TimeTagger.CustomMeasurementBase_stop_all_custom_measurements()

    def register_channel(self, channel):
        r"""register_channel(self, channel)"""
        return _TimeTagger.CustomMeasurementBase_register_channel(self, channel)

    def unregister_channel(self, channel):
        r"""unregister_channel(self, channel)"""
        return _TimeTagger.CustomMeasurementBase_unregister_channel(self, channel)

    def finalize_init(self):
        r"""finalize_init(self)"""
        return _TimeTagger.CustomMeasurementBase_finalize_init(self)

    def is_running(self):
        r"""is_running(self) -> bool"""
        return _TimeTagger.CustomMeasurementBase_is_running(self)

    def _lock(self):
        r"""_lock(self)"""
        return _TimeTagger.CustomMeasurementBase__lock(self)

    def _unlock(self):
        r"""_unlock(self)"""
        return _TimeTagger.CustomMeasurementBase__unlock(self)

    def next_impl(self, incoming_tags, begin_time, end_time):
        r"""next_impl(self, incoming_tags, begin_time, end_time) -> bool"""
        return _TimeTagger.CustomMeasurementBase_next_impl(self, incoming_tags, begin_time, end_time)

    def next_impl_cs(self, tags_ptr, num_tags, begin_time, end_time):
        r"""next_impl_cs(self, tags_ptr, num_tags, begin_time, end_time)"""
        return _TimeTagger.CustomMeasurementBase_next_impl_cs(self, tags_ptr, num_tags, begin_time, end_time)

    def clear_impl(self):
        r"""clear_impl(self)"""
        return _TimeTagger.CustomMeasurementBase_clear_impl(self)

    def on_start(self):
        r"""on_start(self)"""
        return _TimeTagger.CustomMeasurementBase_on_start(self)

    def on_stop(self):
        r"""on_stop(self)"""
        return _TimeTagger.CustomMeasurementBase_on_stop(self)
    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_CustomMeasurementBase(self)
        return weakref.proxy(self)

# Register CustomMeasurementBase in _TimeTagger:
_TimeTagger.CustomMeasurementBase_swigregister(CustomMeasurementBase)

def CustomMeasurementBase_stop_all_custom_measurements():
    r"""CustomMeasurementBase_stop_all_custom_measurements()"""
    return _TimeTagger.CustomMeasurementBase_stop_all_custom_measurements()

class FlimAbstract(IteratorBase):
    r"""Proxy of C++ FlimAbstract class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_FlimAbstract

    def isAcquiring(self):
        r"""isAcquiring(self) -> bool"""
        return _TimeTagger.FlimAbstract_isAcquiring(self)

# Register FlimAbstract in _TimeTagger:
_TimeTagger.FlimAbstract_swigregister(FlimAbstract)

class FlimBase(FlimAbstract):
    r"""Proxy of C++ FlimBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, start_channel, click_channel, pixel_begin_channel, n_pixels, n_bins, binwidth, pixel_end_channel=CHANNEL_UNUSED, frame_begin_channel=CHANNEL_UNUSED, finish_after_outputframe=0, n_frame_average=1, pre_initialize=True) -> FlimBase"""
        if self.__class__ == FlimBase:
            _self = None
        else:
            _self = self
        _TimeTagger.FlimBase_swiginit(self, _TimeTagger.new_FlimBase(_self, *args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_FlimBase

    def initialize(self):
        r"""initialize(self)"""
        return _TimeTagger.FlimBase_initialize(self)

    def frameReady(self, frame_number, data, pixel_begin_times, pixel_end_times, frame_begin_time, frame_end_time):
        r"""frameReady(self, frame_number, data, pixel_begin_times, pixel_end_times, frame_begin_time, frame_end_time)"""
        return _TimeTagger.FlimBase_frameReady(self, frame_number, data, pixel_begin_times, pixel_end_times, frame_begin_time, frame_end_time)
    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_FlimBase(self)
        return weakref.proxy(self)

# Register FlimBase in _TimeTagger:
_TimeTagger.FlimBase_swigregister(FlimBase)

class FlimFrameInfo(object):
    r"""Proxy of C++ FlimFrameInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getFrameNumber(self):
        r"""getFrameNumber(self) -> int32_t"""
        return _TimeTagger.FlimFrameInfo_getFrameNumber(self)

    def isValid(self):
        r"""isValid(self) -> bool"""
        return _TimeTagger.FlimFrameInfo_isValid(self)

    def getPixelPosition(self):
        r"""getPixelPosition(self) -> uint32_t"""
        return _TimeTagger.FlimFrameInfo_getPixelPosition(self)

    def getHistograms(self):
        r"""getHistograms(self)"""
        return _TimeTagger.FlimFrameInfo_getHistograms(self)

    def getIntensities(self):
        r"""getIntensities(self)"""
        return _TimeTagger.FlimFrameInfo_getIntensities(self)

    def getSummedCounts(self):
        r"""getSummedCounts(self)"""
        return _TimeTagger.FlimFrameInfo_getSummedCounts(self)

    def getPixelBegins(self):
        r"""getPixelBegins(self)"""
        return _TimeTagger.FlimFrameInfo_getPixelBegins(self)

    def getPixelEnds(self):
        r"""getPixelEnds(self)"""
        return _TimeTagger.FlimFrameInfo_getPixelEnds(self)
    pixels = property(_TimeTagger.FlimFrameInfo_pixels_get, _TimeTagger.FlimFrameInfo_pixels_set, doc=r"""pixels""")
    bins = property(_TimeTagger.FlimFrameInfo_bins_get, _TimeTagger.FlimFrameInfo_bins_set, doc=r"""bins""")
    frame_number = property(_TimeTagger.FlimFrameInfo_frame_number_get, _TimeTagger.FlimFrameInfo_frame_number_set, doc=r"""frame_number""")
    pixel_position = property(_TimeTagger.FlimFrameInfo_pixel_position_get, _TimeTagger.FlimFrameInfo_pixel_position_set, doc=r"""pixel_position""")

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


    def __init__(self):
        r"""__init__(self) -> FlimFrameInfo"""
        _TimeTagger.FlimFrameInfo_swiginit(self, _TimeTagger.new_FlimFrameInfo())
    __swig_destroy__ = _TimeTagger.delete_FlimFrameInfo

# Register FlimFrameInfo in _TimeTagger:
_TimeTagger.FlimFrameInfo_swigregister(FlimFrameInfo)

class Flim(FlimAbstract):
    r"""Proxy of C++ Flim class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, start_channel, click_channel, pixel_begin_channel, n_pixels, n_bins, binwidth, pixel_end_channel=CHANNEL_UNUSED, frame_begin_channel=CHANNEL_UNUSED, finish_after_outputframe=0, n_frame_average=1, pre_initialize=True) -> Flim"""
        if self.__class__ == Flim:
            _self = None
        else:
            _self = self
        _TimeTagger.Flim_swiginit(self, _TimeTagger.new_Flim(_self, *args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Flim

    def initialize(self):
        r"""initialize(self)"""
        return _TimeTagger.Flim_initialize(self)

    def getReadyFrame(self, index=-1):
        r"""getReadyFrame(self, index=-1)"""
        return _TimeTagger.Flim_getReadyFrame(self, index)

    def getReadyFrameIntensity(self, index=-1):
        r"""getReadyFrameIntensity(self, index=-1)"""
        return _TimeTagger.Flim_getReadyFrameIntensity(self, index)

    def getCurrentFrame(self):
        r"""getCurrentFrame(self)"""
        return _TimeTagger.Flim_getCurrentFrame(self)

    def getCurrentFrameIntensity(self):
        r"""getCurrentFrameIntensity(self)"""
        return _TimeTagger.Flim_getCurrentFrameIntensity(self)

    def getSummedFrames(self, only_ready_frames=True, clear_summed=False):
        r"""getSummedFrames(self, only_ready_frames=True, clear_summed=False)"""
        return _TimeTagger.Flim_getSummedFrames(self, only_ready_frames, clear_summed)

    def getSummedFramesIntensity(self, only_ready_frames=True, clear_summed=False):
        r"""getSummedFramesIntensity(self, only_ready_frames=True, clear_summed=False)"""
        return _TimeTagger.Flim_getSummedFramesIntensity(self, only_ready_frames, clear_summed)

    def getReadyFrameEx(self, index=-1):
        r"""getReadyFrameEx(self, index=-1) -> FlimFrameInfo"""
        return _TimeTagger.Flim_getReadyFrameEx(self, index)

    def getCurrentFrameEx(self):
        r"""getCurrentFrameEx(self) -> FlimFrameInfo"""
        return _TimeTagger.Flim_getCurrentFrameEx(self)

    def getSummedFramesEx(self, only_ready_frames=True, clear_summed=False):
        r"""getSummedFramesEx(self, only_ready_frames=True, clear_summed=False) -> FlimFrameInfo"""
        return _TimeTagger.Flim_getSummedFramesEx(self, only_ready_frames, clear_summed)

    def getFramesAcquired(self):
        r"""getFramesAcquired(self) -> uint32_t"""
        return _TimeTagger.Flim_getFramesAcquired(self)

    def getIndex(self):
        r"""getIndex(self)"""
        return _TimeTagger.Flim_getIndex(self)

    def frameReady(self, frame_number, data, pixel_begin_times, pixel_end_times, frame_begin_time, frame_end_time):
        r"""frameReady(self, frame_number, data, pixel_begin_times, pixel_end_times, frame_begin_time, frame_end_time)"""
        return _TimeTagger.Flim_frameReady(self, frame_number, data, pixel_begin_times, pixel_end_times, frame_begin_time, frame_end_time)
    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_Flim(self)
        return weakref.proxy(self)

# Register Flim in _TimeTagger:
_TimeTagger.Flim_swigregister(Flim)

class SyntheticSingleTag(IteratorBase):
    r"""Proxy of C++ SyntheticSingleTag class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, base_channel=CHANNEL_UNUSED) -> SyntheticSingleTag"""
        _TimeTagger.SyntheticSingleTag_swiginit(self, _TimeTagger.new_SyntheticSingleTag(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_SyntheticSingleTag

    def trigger(self):
        r"""trigger(self)"""
        return _TimeTagger.SyntheticSingleTag_trigger(self)

    def getChannel(self):
        r"""getChannel(self) -> int"""
        return _TimeTagger.SyntheticSingleTag_getChannel(self)

# Register SyntheticSingleTag in _TimeTagger:
_TimeTagger.SyntheticSingleTag_swigregister(SyntheticSingleTag)


class CustomMeasurement(CustomMeasurementBase):
  def __init__(self, time_tagger):
    CustomMeasurementBase.__init__(self, time_tagger)
    self.showError = True
    self.dtype = numpy.dtype({'names':['type','missed_events','channel','time'], 'formats':['u1','<u2','<i4','<i8'], 'offsets':[0,2,4,8], 'itemsize':16}, align=True)

  def process(self, incoming_tags, begin_time, end_time):
    if self.showError:
        print("ERROR: The process() method of the Python-CustomMeasurement must be overwritten!")
        self.showError = False
    pass

  def next_impl(self, incoming_tags, begin_time, end_time):
    tags = incoming_tags.view(self.dtype)
    try:
      self.process(tags, begin_time, end_time)
    except Exception as inst:
      import traceback
      traceback.print_exc()
      raise inst

    return False

# Stop all custom measurements on shutdown. Else the virtual function might still be called while the interpreter is going to shut down.
__import__('atexit').register(CustomMeasurementBase.stop_all_custom_measurements)

def setLogger(callback):
  """
  Sets the notifier callback which is called for each log message

  :param callback: The callback for the log message, like lambda level, msg: print(msg)
  :return: returns nothing
  """
  class PyLogger(CustomLogger):
    def __init__(self, callback):
      CustomLogger.__init__(self)
      self.callback = callback
      self.enable()
    def Log(self, level, message):
      self.callback(level, message)
  setLogger.logger = None
  if callback:
    setLogger.logger = PyLogger(callback)
setLogger.logger = None

def freeTimeTagger(tagger):
    r"""freeTimeTagger(tagger) -> bool"""
    if not isinstance(tagger, TimeTaggerBase):
        raise TypeError('in method \'freeTimeTagger\', argument 1 of type \'TimeTaggerBase\'')
    if tagger.this and tagger.thisown:
        tagger.__swig_destroy__(tagger)
        tagger.this = None
        return True
    return False


try:
  from enum import IntEnum
except:
  IntEnum = object
try:
  from enum import IntFlag
except:
  IntFlag = IntEnum

class CoincidenceTimestamp(IntEnum):
  Last = CoincidenceTimestamp_Last
  Average = CoincidenceTimestamp_Average
  First = CoincidenceTimestamp_First
  ListedFirst = CoincidenceTimestamp_ListedFirst

class Resolution(IntEnum):
  Standard = Resolution_Standard
  HighResA = Resolution_HighResA
  HighResB = Resolution_HighResB
  HighResC = Resolution_HighResC

class ChannelEdge(IntFlag):
  All = ChannelEdge_All
  Rising = ChannelEdge_Rising
  Falling = ChannelEdge_Falling
  HighResAll = ChannelEdge_HighResAll
  HighResRising = ChannelEdge_HighResRising
  HighResFalling = ChannelEdge_HighResFalling
  StandardAll = ChannelEdge_StandardAll
  StandardRising = ChannelEdge_StandardRising
  StandardFalling = ChannelEdge_StandardFalling

class UsageStatisticsStatus(IntEnum):
  Disabled = UsageStatisticsStatus_Disabled
  Collecting = UsageStatisticsStatus_Collecting
  CollectingAndUploading = UsageStatisticsStatus_CollectingAndUploading

class FrontendType(IntEnum):
  Undefined = FrontendType_Undefined
  WebApp = FrontendType_WebApp
  Firefly = FrontendType_Firefly
  Pyro5RPC = FrontendType_Pyro5RPC
  UserFrontend = FrontendType_UserFrontend

class LanguageUsed(IntEnum):
  Cpp = LanguageUsed_Cpp
  Python = LanguageUsed_Python
  Csharp = LanguageUsed_Csharp
  Matlab = LanguageUsed_Matlab
  Labview = LanguageUsed_Labview
  Mathematica = LanguageUsed_Mathematica
  Unknown = LanguageUsed_Unknown

del IntEnum
del IntFlag



